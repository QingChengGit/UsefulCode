{"version":3,"sources":["webpack:///webpack/bootstrap 45f3558246206c2dcdca","webpack:///../UsefulCode/test/specs/binaryTree_spec.js","webpack:///../UsefulCode/binaryTree.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC,kBAAiB,oBAAoB;AACrC,kBAAiB,mBAAmB;AACpC,kBAAiB;AACjB;AACA;AACA,MAAK;;AAEL;AACA,uBAAsB;AACtB;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC,E;;;;;;;;;AC9DD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 45f3558246206c2dcdca","/**\n * Created by qingcheng on 16/11/12.\n */\nvar BinaryTree = require('../../binaryTree');\n\ndescribe('BinaryTree algorithm test', function() {\n    \"use strict\";\n    var tree = new BinaryTree();\n    beforeEach(function() {\n        tree.init([\n                {key: 2, val: 'we'},\n                {key: 36, val: '俄访问'},\n                {key:12, val: 'eqr'},\n                {key:5, val: 'go'}\n            ]\n        );\n    });\n\n    it('init', function() {\n        //spyOn跟踪函数调用;spayOn chain and.callThrough will delegate it to actual implementation!ßß\n        spyOn(tree, 'addNode').and.callThrough();\n        tree.init([{key: 66, val: 're'}]);\n        expect(tree.addNode).toHaveBeenCalled();\n        expect(tree.getNodeByKey(66).val).toBe('re');\n    });\n\n    it('preTravers', function() {\n        expect(tree.preTravers()).toBe('2,36,12,5');\n    });\n\n    it('middleTravers', function() {\n        expect(tree.middleTravers()).toBe('2,5,12,36');\n    });\n\n    it('postTravers', function() {\n        expect(tree.postTravers()).toBe('5,12,36,2');\n    });\n\n    it('getNodeByKey', function() {\n        expect(tree.getNodeByKey(12).val).toBe('eqr');\n        expect(tree.getNodeByKey(5).key).toBe(5);\n        expect(tree.getNodeByKey(18)).toBe(null);\n        expect(tree.getNodeByKey()).toBe(null);\n    });\n\n    it('addNode', function() {\n        tree.addNode(1, 'qingcheng');\n        expect(tree.getNodeByKey(1).val).toBe('qingcheng');\n        tree.addNode(22);\n        expect(tree.getNodeByKey(22).val).not.toBeTruthy();\n        tree.addNode(0, 'zero');\n        expect(tree.getNodeByKey(0).val).toBe('zero');\n        expect(function() {\n            tree.addNode('', '34')\n        }).toThrow();\n    });\n\n    it('deleteNode', function() {\n        expect(tree.deleteNode(12).key).toBe(12);\n        expect(tree.getNodeByKey(12)).toBe(null);\n        expect(tree.deleteNode(34)).toBe(null);\n    });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../UsefulCode/test/specs/binaryTree_spec.js\n// module id = 0\n// module chunks = 0","/**\n * Created by qingcheng on 16/11/8.\n */\n/*\n 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），\n 是指一棵空树或者具有下列性质的二叉树：\n\n 1. 若任意节点的左子树不空，则左子树上所有结点的键值均小于它的根结点的键值；\n\n 2. 若任意节点的右子树不空，则右子树上所有结点的键值均大于它的根结点的键值；\n\n 3. 任意节点的左、右子树也分别为二叉查找树。\n\n 4. 没有键值相等的节点（no duplicate nodes）\n */\n\nfunction Node(key, val) {\n    \"use strict\";\n    if(key != '0' && !key){\n        throw Error(\"node's key can not be empty\");\n    }\n    this.key = key;\n    this.val = val;\n    this.parent = this.left = this.right = void 0;\n}\n\nfunction BinaryTree(comparison) {\n    \"use strict\";\n    this.root = void 0;\n    this.comparison = comparison;\n}\n\nBinaryTree.prototype.addNode = function addNode(key, val) {\n    \"use strict\";\n    var p = new Node(key, val);\n    _insertNode(this, p);\n    return p;\n};\n\nBinaryTree.prototype.deleteNode = function deleteNode(key) {\n    \"use strict\";\n    var target = this.getNodeByKey(key),\n        chainRoot,\n        chainLeaf,\n        chainOneChild,\n        chainTwoChild;\n\n    if(!target){\n        return null;\n    }\n    chainRoot = new Chain(_deleteRootNode);\n    chainLeaf = new Chain(_deleteLeafNode);\n    chainOneChild = new Chain(_deleteHasOneChildNode);\n    chainTwoChild = new Chain(_deleteHasTwoChildNode);\n\n    chainRoot.setNextProcessor(chainLeaf);\n    chainLeaf.setNextProcessor(chainOneChild);\n    chainOneChild.setNextProcessor(chainTwoChild);\n\n    chainRoot.run(this, target);\n    return target;\n};\n\nBinaryTree.prototype.getNodeByKey = function getNodeByKey(key) {\n    \"use strict\";\n    return _searchByKey(this, key);\n};\n\nBinaryTree.prototype.preTravers = function preTravers() {\n    \"use strict\";\n    //前序遍历\n    var root = this.root,\n        rs = [];\n\n    if(!root){\n        return '';\n    }\n    _preTravers(root, rs);\n\n    return rs.join();\n};\n\nBinaryTree.prototype.middleTravers = function middleTravers() {\n    \"use strict\";\n    //中序遍历\n    var root = this.root,\n        rs = [];\n\n    if(!root){\n        return '';\n    }\n    _middleTravers(root, rs);\n\n    return rs.join();\n};\n\nBinaryTree.prototype.postTravers = function postTravers() {\n    \"use strict\";\n    //后序遍历\n    var root = this.root,\n        rs = [];\n\n    if(!root){\n        return '';\n    }\n    _postTravers(root, rs);\n\n    return rs.join();\n};\n\nBinaryTree.prototype.init = function init(data) {\n    \"use strict\";\n    var self = this;\n    if(typeof data === 'undefined'){\n        _clearTree(self);\n        return;\n    }\n    if(Object.prototype.toString.call(data) === '[object Array]'){\n        _clearTree(self);\n        data.forEach(function(item, index) {\n            self.addNode(item.key, item.val);\n        });\n    }\n};\n\nfunction _insertNode(tree, node) {\n    \"use strict\";\n    var p,\n        flag = true;\n\n    if(!tree.root){\n        tree.root = node;\n        return;\n    }\n    p = tree.root;\n    while(p && flag){\n        if(_compare(node.key, p.key, tree.comparison)){\n            //node's key greater than p's key\n            if(!p.right){\n                p.right = node;\n                flag = false;\n            }else{\n                p = p.right;\n            }\n        }else{\n            if(!p.left){\n                p.left = node;\n                flag = false;\n            }else{\n                p = p.left;\n            }\n        }\n    }\n    node.parent = p;\n}\n\nfunction _searchByKey(tree, key) {\n    \"use strict\";\n    var p;\n\n    p = tree.root;\n    if((key != '0' && !key) || !p){\n        return null;\n    }\n    while(p){\n        if(p.key === key){\n            return p;\n        }else{\n            if(_compare(key, p.key)){\n                p = p.right;\n            }else{\n                p = p.left;\n            }\n        }\n    }\n    return null;\n}\n\nfunction _compare(a, b, comparison) {\n    \"use strict\";\n    // if a > b return true otherwise return false;\n    if(typeof comparison === 'function'){\n        return comparison(a, b);\n    }else{\n        return a > b;\n    }\n}\n\nfunction _clearTree(tree) {\n    \"use strict\";\n    if(tree.root){\n        //clear tree\n        tree.root.left = tree.root.right = null;\n        tree.root = null;\n    }\n}\n\nfunction _deleteRootNode(tree, node) {\n    var successor;\n\n    if(node.parent){\n        return \"nextProcess\";\n    }\n    if(!node.left && !node.right){\n        tree.root = null;\n    }else if(node.left && node.right){\n        successor = _getSuccessor(node);\n        tree.root = successor;\n        successor.parent = null;\n        successor.left = node.left;\n        successor.right = node.right;\n    }else{\n        tree.root = node.left || node.right;\n        if(node.left){\n            node.left.parent = null;\n        }else{\n            node.right.parent = null;\n        }\n    }\n    node.left = node.right = null;\n}\n\nfunction _deleteLeafNode(tree, node) {\n    if(node.left || node.right){\n        return \"nextProcess\";\n    }\n    //node is leaf node\n    if(node.parent.left === node){\n        node.parent.left = null;\n    }else{\n        node.parent.right = null;\n    }\n    node.parent = null;\n}\n\nfunction _deleteHasOneChildNode(tree, node) {\n    if(node.left && node.right){\n        return \"nextProcess\";\n    }\n    if(node.parent.left === node){\n        node.parent.left = node.left || node.right;\n        if(node.left){\n            node.left.parent = node.parent;\n            node.left = null;\n        }else{\n            node.right.parent = node.parent;\n            node.right = null;\n        }\n        node.parent = null;\n    }\n}\n\nfunction _deleteHasTwoChildNode(tree, node) {\n    var successor;\n\n    if(!(node.left && node.right)){\n        return \"nextProcess\";\n    }\n    successor = _getSuccessor(node);\n    successor.parent = node.parent;\n    successor.left = node.left;\n    successor.right = node.right;\n\n    node.parent = node.left = node.right = null;\n}\n/*\n    获取node节点的后继节点，主要用于删除二叉树中的某个节点有两个子节点的情况\n */\nfunction _getSuccessor(node) {\n    var cur = node;\n        p = node.left;\n\n    while(p){\n        p = p.left;\n        cur = cur.left;\n    }\n    return cur;\n}\n\nfunction Chain(fn){\n    this.fn = fn;\n    this.nextProcessor = null;\n}\n\nChain.prototype.setNextProcessor = function setNextProcessor(processor) {\n    if(!processor || processor instanceof Chain){\n        this.nextProcessor = processor;\n    }\n};\n\nChain.prototype.run = function runChain() {\n    var rs,\n        self = this;\n\n    rs = this.fn.apply(self, arguments);\n    if(rs === 'nextProcess'){\n        this.nextProcessor && this.nextProcessor.run.apply(this.nextProcessor, arguments);\n    }\n};\n\nfunction _preTravers(node, out) {\n    \"use strict\";\n    out.push(node.key);\n\n    if(node.left){\n        _preTravers(node.left, out);\n    }\n    if(node.right){\n        _preTravers(node.right, out);\n    }\n}\n\nfunction _middleTravers(node, out) {\n    \"use strict\";\n\n    if(node.left){\n        _middleTravers(node.left, out);\n    }\n    out.push(node.key);\n    if(node.right){\n        _middleTravers(node.right, out);\n    }\n}\n\nfunction _postTravers(node, out) {\n    \"use strict\";\n\n    if(node.left){\n        _postTravers(node.left, out);\n    }\n    if(node.right){\n        _postTravers(node.right, out);\n    }\n    out.push(node.key);\n}\n\nmodule.exports = BinaryTree;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../UsefulCode/binaryTree.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}